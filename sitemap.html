<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
            }
        }
    </script>
<title>Sitemap — Final Prototype</title>
<style>
  :root{
    --bg-deep:#04061a;
    --bg-mid:#070a24;

    --ink-main:#f6f7ff;
    --ink-muted:#a2a9c8;

    --neon-pink:#ff7ac0;
    --neon-cyan:#6df6ff;
    --neon-core:#7aa4ff;

    --panel-border:rgba(160,185,245,0.46);
    --shadow-soft:0 26px 80px rgba(0,0,0,0.9);

    --slot-width:22vw;
    --panel-width:32vw;

    font-family:-apple-system,"SF Pro Text","SF Pro Display","Inter","Noto Sans JP",system-ui,sans-serif;
  }

  html,body{
    margin:0;
    height:100%;
    color:var(--ink-main);
    background:
      radial-gradient(circle at 65% 20%, rgba(255,120,210,0.44) 0, transparent 55%),
      radial-gradient(circle at 25% 82%, rgba(100,245,255,0.42) 0, transparent 55%),
      linear-gradient(135deg,#090e2e,#070b27 32%,#050920 78%,#04061a);
    overflow:hidden;
  }

  #app{
    position:relative;
    width:100%;
    height:100vh;
    overflow:hidden;
  }

  #canvas{
    position:absolute;
    inset:0;
    z-index:1;
  }

  canvas{
    display:block;
    width:100%;
    height:100%;
  }

  /* ========= 左：軌道コンソール ========= */

  .slot{
    position:fixed;
    z-index:30;
    left:0;
    top:0;
    bottom:0;
    width:var(--slot-width);
    display:flex;
    justify-content:flex-start;
    align-items:center;
    pointer-events:none;
    padding-left:2.6vw;
  }

  .slotInner{
    position:relative;
    pointer-events:auto;

    width:100%;
    max-width:280px;
    height:calc(100vh - 10vh);
    margin:5vh 0;

    padding:0;
    box-sizing:border-box;
    overflow-y:auto;
    -webkit-overflow-scrolling:touch;
    scroll-behavior:smooth;

    background:
      radial-gradient(circle at 0% 0%, rgba(160,190,255,0.3) 0, transparent 65%),
      linear-gradient(180deg,rgba(10,14,38,0.98),rgba(6,9,26,0.98));
    border-radius:22px 26px 26px 22px;
    box-shadow:var(--shadow-soft);
    border:1px solid var(--panel-border);
    backdrop-filter:blur(22px) saturate(165%);
    -webkit-backdrop-filter:blur(22px) saturate(165%);
  }

  .slotInner::before{
    content:"";
    position:absolute;
    left:42px;
    top:22px;
    bottom:22px;
    width:2px;
    border-radius:999px;
    background:
      linear-gradient(
        to bottom,
        rgba(120,155,235,0.2),
        rgba(170,205,255,0.95),
        rgba(120,155,235,0.2)
      );
    opacity:0.95;
    pointer-events:none;
  }

  .slotInner::-webkit-scrollbar{ display:none; }

  /* スクロール端でも中央に寄せるためのスペーサー */
  .slotSpacer{
    width:100%;
  }

  .slotItem{
    position:relative;
    margin:4px 0;
    padding:7px 20px 7px 64px;
    border-radius:999px;
    text-align:left;
    font-size:14px;
    font-weight:500;
    letter-spacing:.03em;
    cursor:pointer;
    user-select:none;

    color:var(--ink-muted);
    background:transparent;
    transform:translateX(0) scale(0.9);
    opacity:.5;
    transition:
      background .22s ease,
      color .22s ease,
      box-shadow .22s ease,
      transform .22s ease,
      opacity .22s ease;
  }

  .slotItem::before{
    content:"";
    position:absolute;
    left:34px;
    top:50%;
    width:9px;
    height:9px;
    border-radius:50%;
    background:#7079a7;
    transform:translateY(-50%);
    box-shadow:0 0 0 0 rgba(0,0,0,0);
    transition:
      background .2s ease,
      box-shadow .2s ease,
      transform .18s ease;
  }

  .slotItem:hover{
    color:#f0f3ff;
  }

  .slotItem.center{
    color:#f7f8ff;
    background:
      radial-gradient(circle at 0% 50%, rgba(150,190,255,0.7) 0, transparent 72%);
    box-shadow:0 18px 55px rgba(0,0,0,0.95);
    transform:translateX(-22px) scale(1.02);
    opacity:1;
  }

  .slotItem.center::before{
    transform:translate(-1px,-50%) scale(1.15);
    box-shadow:0 0 0 4px rgba(140,205,255,0.5);
  }

  /* カテゴリ別ドット */
  .slotItem:nth-child(2)::before{ background:var(--neon-core); }
  .slotItem:nth-child(3)::before,
  .slotItem:nth-child(4)::before,
  .slotItem:nth-child(5)::before,
  .slotItem:nth-child(6)::before,
  .slotItem:nth-child(7)::before,
  .slotItem:nth-child(8)::before{
    background:var(--neon-pink);
  }
  .slotItem:nth-child(9)::before,
  .slotItem:nth-child(10)::before,
  .slotItem:nth-child(11)::before,
  .slotItem:nth-child(12)::before,
  .slotItem:nth-child(13)::before{
    background:var(--neon-cyan);
  }
  .slotItem:nth-child(14)::before,
  .slotItem:nth-child(15)::before{
    background:#ce8bff;
  }
  .slotItem:nth-child(16)::before,
  .slotItem:nth-child(17)::before,
  .slotItem:nth-child(18)::before,
  .slotItem:nth-child(19)::before,
  .slotItem:nth-child(20)::before{
    background:#f9e08a;
  }

  /* ========= HUD ラベル ========= */

  .label{
  min-width:34px;
  padding:3px 10px;
  border-radius:999px;
  font-size:11px;
  font-weight:600;
  letter-spacing:.18em;
  text-transform:uppercase;
  background:rgba(5,8,20,0.92) !important;
  color:#f5f7ff !important;
  border:1px solid rgba(150,180,255,0.9);
  box-shadow:0 12px 30px rgba(0,0,0,0.9);
  display:flex;
  align-items:center;
  justify-content:center;
}

.label--active{
  border-color:rgba(255,255,255,0.95) !important;
  box-shadow:
    0 0 0 1px rgba(255,255,255,0.55),
    0 16px 38px rgba(0,0,0,0.95);
  background:
    linear-gradient(90deg,
      rgba(95,246,255,0.42),
      rgba(255,122,192,0.6)
    ) !important;
}

  /* ========= 右：観測ログパネル ========= */

  .panel{
    position:fixed;
    z-index:32;
    right:4vw;
    top:50%;
    transform:translateY(-50%);
    width:var(--panel-width);
    max-width:460px;
    min-width:300px;
    pointer-events:none;
  }

  .info{
    pointer-events:auto;
    background:
      radial-gradient(circle at 0% 0%, rgba(150,190,255,0.32) 0, transparent 70%),
      linear-gradient(135deg,rgba(15,20,46,0.98),rgba(6,9,28,0.98));
    padding:22px 24px 20px;
    border-radius:18px;
    border:1px solid var(--panel-border);
    box-shadow:var(--shadow-soft);
    backdrop-filter:blur(24px) saturate(170%);
    -webkit-backdrop-filter:blur(24px) saturate(170%);

    opacity:0;
    transform:translateX(14px);
    transition:opacity .4s ease, transform .4s ease;
  }

  .info.show{
    opacity:1;
    transform:translateX(0);
  }

  .chap{
    font-size:11px;
    text-transform:uppercase;
    letter-spacing:.18em;
    margin-bottom:6px;
    font-weight:600;
    color:var(--ink-muted);
  }

  .title{
    font-size:22px;
    font-weight:700;
    line-height:1.18;
    margin-bottom:8px;
    color:#fdfdff;
  }

  .desc{
    font-size:14px;
    line-height:1.7;
    color:#d4daf6;
    max-height:52vh;
    overflow:auto;
    padding-right:6px;
  }

  .desc::-webkit-scrollbar{
    width:4px;
  }
  .desc::-webkit-scrollbar-thumb{
    background:rgba(150,162,222,0.85);
    border-radius:999px;
  }
  .desc::-webkit-scrollbar-track{
    background:transparent;
  }

  /* ========= 下：操作ヒント ========= */

  .hint{
    position:fixed;
    left:calc(var(--slot-width) + 2.6vw);
    bottom:4vh;
    font-size:12px;
    color:var(--ink-muted);
    letter-spacing:.03em;
    z-index:20;

    padding:8px 16px;
    border-radius:999px;
    background:rgba(7,9,26,0.94);
    border:1px solid rgba(155,175,235,0.35);
    box-shadow:0 18px 45px rgba(0,0,0,0.9);
    backdrop-filter:blur(16px);
    -webkit-backdrop-filter:blur(16px);
  }

  .ui-text{
    opacity:0;
    transform:translateY(6px);
    transition:opacity .32s ease, transform .32s ease;
  }

  .ui-text.visible{
    opacity:1;
    transform:translateY(0);
  }

  /* ========= レスポンシブ ========= */

  @media(max-width:900px){
    :root{
      --slot-width:30vw;
      --panel-width:60vw;
    }
    .slot{
      padding-left:3vw;
    }
    .panel{
      right:3vw;
    }
    .title{
      font-size:18px;
    }
  }
</style>



</head>
<body>
<div id="app">
  <div class="slot"><div id="slotInner" class="slotInner" aria-label="ページリスト"></div></div>
  <div id="canvas"></div>

  <div class="panel">
    <div id="info" class="info" aria-live="polite">
      <div id="chap" class="chap ui-text"></div>
      <div id="title" class="title ui-text"></div>
      <div id="desc" class="desc ui-text"></div>
    </div>
  </div>

  <div class="hint">ドラッグで回転 / スロット上下で即選択 / 面クリックで表示 → 表示中に同面クリックで遷移</div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
  import { CSS2DRenderer, CSS2DObject } from "https://unpkg.com/three@0.165.0/examples/jsm/renderers/CSS2DRenderer.js";

  // ================== CONTENT & CATEGORY ==================

  const PAGES = [
    {category:0, title:"トップページ", slug:"index.html", desc:"「@IronY ー(サブタイ)ー」のトップページ。ここから様々なページへと飛ぶことが可能です。迷った方はまずこちらのページから、このサイトを踏破する第一歩を踏み出してみて下さい。"},
    {category:0, title:"序論", slug:"page2.html", desc:"そもそもSNSとは一体何なのか、そんな最も前提的な、しかしそれでいてこの問題の根幹に根付く「SNSの定義」を明らかにします。知の探究が、このページから幕を開けます。"},
    {category:1, title:"本論：系譜", slug:"page3.html", desc:"本質は歴史にこそ隠れた、とはよく言うものです。SNSとは一体どのようにして今の強固な立ち位置を手に入れたのか、その過去を紐解きます。そこに本質があり、同時に全てを解き明かす謎が隠れているのです。"},
    {category:1, title:"本論：両義", slug:"page4.html", desc:"社会に変革という名の深い爪痕を残したSNS。しかしそのSNSの、光が落とした闇に気づくことができていたでしょうか？そんな真実と虚構の二面性、両義的なその存在を今知覚しましょう。"},
    {category:1, title:"本論：自己", slug:"page5.html", desc:"SNSに浸食されていく日常時間。私たちの体には、私たちの思考には一体何が起きているのでしょうか。SNSが生み出した「絶え間ない常時接続」から抜け出すために、まずはその問題を理解しましょう。"},
    {category:1, title:"本論：資本", slug:"page6.html", desc:"私たちが多用するSNSは、世界中の天才達の「狩場」になりました。SNSによって誕生した新たな支配的資本主義形態の中で、私たちが狩られずに生き残るために、強大な社会構造のメカニズムを知りましょう。"},
    {category:1, title:"本論：記憶", slug:"page7.html", desc:"インターネットは「生きて」います。かつて崇高な理念より生み出された存在「Wayback machine」。しかしそれはインターネットの全てを刻み、やがて黒い部分が表層へと顔を出すようになりました。"},
    {category:1, title:"結論：未来", slug:"page8.html", desc:"問題は、現在のSNSが誰のために、どのような価値観で設計されているかにあります。そして、それを変える力は、私たち一人ひとりの手の中にあるのです。"},
    {category:2, title:"発展論：旧網", slug:"page3_advance.html", desc:"応用トピックでは、Page3「系譜」で扱ったデジタル時代のSNS史の前に存在した、人類の長大なネットワーク構築史を振り返ります。"},
    {category:2, title:"発展論：偽装", slug:"page4_advance.html", desc:"生成AIと情報倫理の関係、偽装・誤情報問題に向き合うための視点を提示します。"},
    {category:2, title:"発展論：依存", slug:"page5_advance.html", desc:"日常化したSNSが依存へ向かうメカニズムを分析し、距離を取るための実践を考えます。"},
    {category:2, title:"発展論：労働", slug:"page6_advance.html", desc:"SNS時代に変容する『労働』を見つめ直し、制作と注意の価値をどう守るかを議論します。"},
    {category:2, title:"発展論：監視", slug:"page7_advance.html", desc:"プライバシーと監視の現状を整理し、制度的な対策や個人の防衛手段を提示します。"},
    {category:3, title:"探求", slug:"interview.html", desc:"専門家の声を通じて現場の実務・研究の知見を届けます。"},
    {category:3, title:"探求からの考察", slug:"interview_summary.html", desc:"インタビューで得た洞察を体系化し、実践的な示唆を整理します。"},
    {category:4, title:"クイズ：試練", slug:"quiz.html", desc:"学んだことを確認するための短い演習を用意しました。"},
    {category:4, title:"参考文献：源泉", slug:"reference.html", desc:"参考文献・引用元を整理した一覧です。"},
    {category:4, title:"サイトマップ：羅針", slug:"sitemap.html", desc:"このサイトマップから各コンテンツへアクセスできます。設計意図も併記しています。"},
    {category:4, title:"用語集", slug:"word_summary.html", desc:"専門用語の定義と簡潔な解説をまとめています。"},
    {category:4, title:"アート解説：鑑識", slug:"art_explain.html", desc:"アート的要素と制作意図の解説です。"}
  ];

  const CATEGORY_NEON = [
    { edge: new THREE.Color(0x7aa4ff) }, // core
    { edge: new THREE.Color(0xff7ac0) }, // main
    { edge: new THREE.Color(0x6df6ff) }, // advance
    { edge: new THREE.Color(0xce8bff) }, // explore
    { edge: new THREE.Color(0xf9e08a) }  // supplement
  ];

  const EDGE_BASE_COLOR = new THREE.Color(0x141827);
  const IDLE_RETURN_MS = 6000;

  // ================== THREE BASIC SETUP ==================

  const container = document.getElementById("canvas");

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(
    42,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0, 0.9, 5.2);
  camera.lookAt(0, -0.2, 0);

  const renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  const labelRenderer = new CSS2DRenderer();
  labelRenderer.setSize(window.innerWidth, window.innerHeight);
  labelRenderer.domElement.style.position = "absolute";
  labelRenderer.domElement.style.top = "0";
  labelRenderer.domElement.style.pointerEvents = "none";
  container.appendChild(labelRenderer.domElement);

  // ---- Lights: key / fill / rim / front ----

  scene.add(new THREE.AmbientLight(0x30344a, 0.75));

  // 右上前：キーライト
  const keyLight = new THREE.DirectionalLight(0xffffff, 1.25);
  keyLight.position.set(4.5, 6.0, 8.0);
  scene.add(keyLight);

  // 左側：フィル（シアン寄り）
  const fillLight = new THREE.DirectionalLight(0x6df6ff, 0.9);
  fillLight.position.set(-5.0, 2.0, 4.0);
  scene.add(fillLight);

  // 後ろ：リム（マゼンタ）
  const rimLight = new THREE.DirectionalLight(0xff7ac0, 0.95);
  rimLight.position.set(-4.0, -3.0, -7.0);
  scene.add(rimLight);

  // 正面寄り：フロントライト（少しシアンを混ぜた白）
  const frontLight = new THREE.DirectionalLight(0xcfdfff, 0.75);
  frontLight.position.set(0, 0.6, 4.0);
  scene.add(frontLight);

  // ================== ICOSAHEDRON & HUD LABELS ==================

  const R = 1.25;
  const geo = new THREE.IcosahedronGeometry(R, 0);
  geo.computeVertexNormals();

  const meshMaterial = new THREE.MeshStandardMaterial({
    color: 0xbfcfe4,
    roughness: 0.36,
    metalness: 0.48,
    flatShading: true,
    vertexColors: false
  });

  const mesh = new THREE.Mesh(geo, meshMaterial);
  scene.add(mesh);

  const edgeMaterial = new THREE.LineBasicMaterial({
    color: EDGE_BASE_COLOR,
    transparent: true,
    opacity: 0.9,
    linewidth: 1
  });
  const edges = new THREE.LineSegments(
    new THREE.EdgesGeometry(geo),
    edgeMaterial
  );
  scene.add(edges);

  const pos = geo.attributes.position;
  const faceCenters = [];
  const labels = [];

  for (let i = 0; i < pos.count; i += 3) {
    const faceIndex = i / 3;

    const a = new THREE.Vector3().fromBufferAttribute(pos, i);
    const b = new THREE.Vector3().fromBufferAttribute(pos, i + 1);
    const c = new THREE.Vector3().fromBufferAttribute(pos, i + 2);
    const center = new THREE.Vector3()
      .addVectors(a, b)
      .add(c)
      .multiplyScalar(1 / 3)
      .normalize()
      .multiplyScalar(R);

    faceCenters.push(center);

    const div = document.createElement("div");
    div.className = "label";
    div.textContent = (faceIndex + 1).toString().padStart(2, "0");

    const label = new CSS2DObject(div);
    label.position.copy(center.clone().normalize().multiplyScalar(R * 1.12));
    labels.push(label);
    mesh.add(label);
  }

  let activeLabelIndex = null;
  function setActiveLabel(index) {
    if (activeLabelIndex !== null && labels[activeLabelIndex]) {
      labels[activeLabelIndex].element.classList.remove("label--active");
    }
    activeLabelIndex = index;
    if (index != null && labels[index]) {
      labels[index].element.classList.add("label--active");
    }
  }

  // ================== NEON GRID WAVE (床) ==================

  const GRID_COLS = 32;
  const GRID_ROWS = 22;
  const TILE_SIZE = 0.24;
  const TILE_GAP  = 0.04;

  const waveGroup = new THREE.Group();
  waveGroup.position.set(0, -1.7, -0.8);
  waveGroup.rotation.set(0, 0, 0);
  scene.add(waveGroup);

  const tileGeo = new THREE.BoxGeometry(TILE_SIZE, 0.04, TILE_SIZE);

  const baseFloorColor = new THREE.Color(0x02030a);  // ほぼ黒に近い床
  const baseEmissive   = new THREE.Color(0x000000);

  let activeFloorColor = new THREE.Color(0x1b3047);
  let activeEmissive   = new THREE.Color(0x06283e);

  const waveMaterial = new THREE.MeshStandardMaterial({
    color: baseFloorColor.clone(),
    roughness: 0.9,
    metalness: 0.3,
    emissive: baseEmissive.clone(),
    emissiveIntensity: 1.0,
    transparent: true,
    opacity: 0.97
  });

  const totalTiles = GRID_COLS * GRID_ROWS;
  const waveMesh = new THREE.InstancedMesh(tileGeo, waveMaterial, totalTiles);
  waveMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  waveGroup.add(waveMesh);

  const tilePositions = [];
  const dummy = new THREE.Object3D();

  let tileIndex = 0;
  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      const x = (c - GRID_COLS / 2 + 0.5) * (TILE_SIZE + TILE_GAP);
      const z = (r - GRID_ROWS / 2 + 0.5) * (TILE_SIZE + TILE_GAP);
      tilePositions.push({ x, z });

      dummy.position.set(x, 0, z);
      dummy.scale.set(1, 1, 1);
      dummy.updateMatrix();
      waveMesh.setMatrixAt(tileIndex++, dummy.matrix);
    }
  }

  let waveTime = 0;
  let waveStrength = 0;

  // 色用の補間変数
  let colorT = 0;          // 0→1→0
  let colorDirection = 0;  // 1: up, -1: down, 0: stop

  function randomPaletteColor() {
    const choices = [
      0x1b3047, // シアン寄りブルー
      0x362148, // マゼンタ寄りパープル
      0x184547, // ティール
      0x3b3154  // ディープパープル
    ];
    const hex = choices[Math.floor(Math.random() * choices.length)];
    return new THREE.Color(hex);
  }

  function kickWave(amount = 1) {
    waveStrength = Math.min(1.7, waveStrength + amount);
    if (waveTime === 0) waveTime = 0.0001;

    // 色をランダムに決めて、黒 → ネオン → 黒 の往復を開始
    activeFloorColor = randomPaletteColor();
    activeEmissive   = activeFloorColor.clone().multiplyScalar(0.22);

    colorT = 0;
    colorDirection = 1;
  }

  function updateWave(dt) {
    if (waveStrength <= 0 && colorDirection === 0) return;

    // 高低差のアニメーション
    if (waveStrength > 0) {
      waveTime += dt;
      const decay = Math.exp(-waveTime * 1.3);
      const strength = waveStrength * decay;

      if (strength < 0.02) {
        waveStrength = 0;
        waveTime = 0;
      }

      const speed = 4.0;
      const freq = 2.3;
      const baseH = 0.04;

      for (let i = 0; i < totalTiles; i++) {
        const pos = tilePositions[i];
        const dist = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
        const wave = Math.sin(dist * freq - waveTime * speed);

        const h = baseH + 0.6 * ((wave + 1) * 0.5) * strength;
        dummy.position.set(pos.x, h * 0.5, pos.z);
        dummy.scale.set(1, h / baseH, 1);
        dummy.updateMatrix();
        waveMesh.setMatrixAt(i, dummy.matrix);
      }
      waveMesh.instanceMatrix.needsUpdate = true;
    }

    // 色の補間：黒 → ネオン → 黒
    if (colorDirection !== 0) {
      colorT += dt * 1.1 * colorDirection;
      if (colorT >= 1) {
        colorT = 1;
        colorDirection = -1;
      } else if (colorT <= 0) {
        colorT = 0;
        colorDirection = 0;
      }
    }

    const mix = colorT;
    waveMaterial.color
      .copy(baseFloorColor)
      .lerp(activeFloorColor, mix);
    waveMaterial.emissive
      .copy(baseEmissive)
      .lerp(activeEmissive, mix);
  }

  // ================== DOM REFERENCES ==================

  const slotInner = document.getElementById("slotInner");
  const infoEl   = document.getElementById("info");
  const chapEl   = document.getElementById("chap");
  const titleEl  = document.getElementById("title");
  const descEl   = document.getElementById("desc");

  const slotItems = [];
  let spacerTop = null;
  let spacerBottom = null;

  // ================== STATE ==================

  let currentIndex = 0;
  let focusIndex   = null;

  let isDraggingCanvas = false;
  let dragMoved = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartRot = new THREE.Euler();
  const dragThreshold = 6;

  let activeTween = null;
  let lastInteractionTime = performance.now();

  function markInteraction() {
    lastInteractionTime = performance.now();
    kickWave(0.9);
  }

  // ================== TWEEN HELPER ==================

  function startTween(duration, onUpdate, onComplete) {
    if (activeTween && activeTween.cancel) {
      activeTween.cancel();
    }
    const startTime = performance.now();
    let cancelled = false;

    activeTween = {
      cancel() { cancelled = true; }
    };

    function frame(now) {
      if (cancelled) return;
      const tRaw = Math.min(1, (now - startTime) / duration);
      const t = tRaw < 0.5
        ? 4 * tRaw * tRaw * tRaw
        : 1 - Math.pow(-2 * tRaw + 2, 3) / 2;

      onUpdate(t);

      if (tRaw < 1) {
        requestAnimationFrame(frame);
      } else {
        activeTween = null;
        if (onComplete) onComplete();
      }
    }

    requestAnimationFrame(frame);
  }

  // ================== SLOT UI ==================

  function buildSlots() {
    slotInner.innerHTML = "";
    slotItems.length = 0;

    spacerTop = document.createElement("div");
    spacerTop.className = "slotSpacer";
    slotInner.appendChild(spacerTop);

    PAGES.forEach((p, i) => {
      const el = document.createElement("div");
      el.className = "slotItem";
      el.textContent = `${i + 1}. ${p.title}`;
      el.dataset.index = String(i);

      el.addEventListener("click", () => {
        markInteraction();
        const idx = i;
        if (focusIndex === idx) {
          window.location.href = PAGES[idx].slug;
        } else {
          openInfo(idx);
        }
      });

      slotInner.appendChild(el);
      slotItems.push(el);
    });

    spacerBottom = document.createElement("div");
    spacerBottom.className = "slotSpacer";
    slotInner.appendChild(spacerBottom);

    updateSlotSpacers();
    requestAnimationFrame(updateSlotAppearance);
  }

  function updateSlotSpacers() {
    if (!spacerTop || !spacerBottom) return;
    const vh = slotInner.clientHeight;
    const pad = Math.max(32, vh * 0.5 - 28);
    spacerTop.style.height = pad + "px";
    spacerBottom.style.height = pad + "px";
  }

  buildSlots();

  function updateSlotAppearance() {
    if (!slotItems.length) return;

    const scrollTop = slotInner.scrollTop;
    const vh = slotInner.clientHeight;
    const centerY = scrollTop + vh / 2;
    const maxDist = vh / 2;

    let nearestIndex = 0;
    let nearestDist = Infinity;

    slotItems.forEach((el, i) => {
      const elCenter = el.offsetTop + el.clientHeight / 2;
      const dist = Math.abs(centerY - elCenter);
      const factor = Math.max(0, 1 - dist / maxDist);
      const scale = 0.88 + 0.22 * factor;
      const opacity = 0.25 + 0.75 * factor;
      const translateX = (1 - factor) * -24;

      el.style.transform = `translateX(${translateX}px) scale(${scale})`;
      el.style.opacity = String(opacity);

      if (dist < nearestDist) {
        nearestDist = dist;
        nearestIndex = i;
      }
    });

    slotItems.forEach((el, i) => {
      if (i === nearestIndex) {
        el.classList.add("center");
      } else {
        el.classList.remove("center");
      }
    });

    if (focusIndex === null && nearestIndex !== currentIndex) {
      selectIndex(nearestIndex, { fromScroll: true });
    }
  }

  slotInner.addEventListener("scroll", () => {
    markInteraction();
    updateSlotAppearance();
  });

  // ================== ORIENTATION HELPERS ==================

  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  const tmpVec3 = new THREE.Vector3();

  function updatePointerFromEvent(event) {
    const rect = renderer.domElement.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    pointer.set(x, y);
  }

  function orientToFace(index, { focus = false, duration = 650 } = {}) {
    if (index < 0 || index >= faceCenters.length) return;

    const fromQuat = mesh.quaternion.clone();
    const targetQuat = (() => {
      const localNormal = faceCenters[index].clone().normalize();
      const worldNormal = localNormal.clone().applyQuaternion(mesh.quaternion).normalize();
      const camDir = tmpVec3.subVectors(camera.position, mesh.position).normalize();
      const rotQuat = new THREE.Quaternion().setFromUnitVectors(
        worldNormal,
        camDir
      );
      return rotQuat.multiply(mesh.quaternion.clone());
    })();

    const fromPos   = mesh.position.clone();
    const targetPos = mesh.position.clone();

    startTween(duration, (t) => {
      mesh.quaternion.copy(fromQuat).slerp(targetQuat, t);
      mesh.position.lerpVectors(fromPos, targetPos, t);
      edges.quaternion.copy(mesh.quaternion);
      edges.position.copy(mesh.position);
    });
  }

  function findNearestFaceIndex() {
    const camDir = tmpVec3
      .subVectors(camera.position, mesh.position)
      .normalize();

    let best = 0;
    let bestDot = -Infinity;

    for (let i = 0; i < faceCenters.length; i++) {
      const dir = faceCenters[i]
        .clone()
        .normalize()
        .applyQuaternion(mesh.quaternion);
      const dot = dir.dot(camDir);
      if (dot > bestDot) {
        bestDot = dot;
        best = i;
      }
    }
    return best;
  }

  // ================== SELECTION & INFO ==================

  function selectIndex(index, { fromScroll = false } = {}) {
    if (index < 0 || index >= PAGES.length) return;
    currentIndex = index;

    if (!fromScroll) {
      const item = slotItems[index];
      if (item) {
        const targetTop =
          item.offsetTop + item.clientHeight / 2 - slotInner.clientHeight / 2;
        slotInner.scrollTo({ top: targetTop, behavior: "smooth" });
        requestAnimationFrame(updateSlotAppearance);
      }
    }

    setActiveLabel(index);

    if (focusIndex === null) {
      orientToFace(index, { focus: false, duration: 550 });
      edgeMaterial.color.copy(EDGE_BASE_COLOR);
      edgeMaterial.opacity = 0.9;
    }
  }

  function openInfo(index) {
    if (index < 0 || index >= PAGES.length) return;
    markInteraction();
    currentIndex = index;
    focusIndex = index;

    const page = PAGES[index];
    chapEl.textContent = `SECTION ${index + 1}`;
    const neon = CATEGORY_NEON[page.category]?.edge || CATEGORY_NEON[0].edge;
    chapEl.style.color = `#${neon.getHexString()}`;

    titleEl.textContent = page.title;
    descEl.textContent = page.desc;

    orientToFace(index, { focus: true, duration: 650 });

    infoEl.classList.add("show");
    document
      .querySelectorAll(".ui-text")
      .forEach((el) => el.classList.add("visible"));

    edgeMaterial.color.copy(neon);
    edgeMaterial.opacity = 1.0;

    setActiveLabel(index);

    const item = slotItems[index];
    if (item) {
      const targetTop =
        item.offsetTop + item.clientHeight / 2 - slotInner.clientHeight / 2;
      slotInner.scrollTo({ top: targetTop, behavior: "smooth" });
      requestAnimationFrame(updateSlotAppearance);
    }
  }

  function closeInfo() {
    if (focusIndex === null) return;
    focusIndex = null;

    infoEl.classList.remove("show");
    document
      .querySelectorAll(".ui-text")
      .forEach((el) => el.classList.remove("visible"));

    edgeMaterial.color.copy(EDGE_BASE_COLOR);
    edgeMaterial.opacity = 0.9;

    orientToFace(currentIndex, { focus: false, duration: 550 });
  }

  // ================== CANVAS POINTER INTERACTION ==================

  renderer.domElement.addEventListener("pointerdown", (event) => {
    markInteraction();
    isDraggingCanvas = true;
    dragMoved = false;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    dragStartRot.copy(mesh.rotation);
    updatePointerFromEvent(event);
    renderer.domElement.setPointerCapture(event.pointerId);
  });

  renderer.domElement.addEventListener("pointermove", (event) => {
    updatePointerFromEvent(event);
    if (!isDraggingCanvas) return;

    const dx = event.clientX - dragStartX;
    const dy = event.clientY - dragStartY;
    const distSq = dx * dx + dy * dy;

    if (!dragMoved && distSq > dragThreshold * dragThreshold) {
      dragMoved = true;
    }

    if (dragMoved && focusIndex === null) {
      mesh.rotation.y = dragStartRot.y + (dx / window.innerWidth) * Math.PI * 1.4;
      mesh.rotation.x = dragStartRot.x + (dy / window.innerHeight) * Math.PI * 1.4;
      edges.rotation.copy(mesh.rotation);
    }
  });

  renderer.domElement.addEventListener("pointerup", (event) => {
    markInteraction();
    renderer.domElement.releasePointerCapture(event.pointerId);
    const wasDragging = dragMoved;
    isDraggingCanvas = false;
    dragMoved = false;

    if (!wasDragging) {
      handleCanvasClick(event);
    } else if (focusIndex === null) {
      const idx = findNearestFaceIndex();
      selectIndex(idx, { fromScroll: false });
    }
  });

  renderer.domElement.addEventListener("pointerleave", (event) => {
    if (!isDraggingCanvas) return;
    renderer.domElement.releasePointerCapture(event.pointerId);
    isDraggingCanvas = false;
    dragMoved = false;
  });

  // ================== FACE CLICK ==================

  function handleCanvasClick(event) {
    updatePointerFromEvent(event);
    raycaster.setFromCamera(pointer, camera);
    const hits = raycaster.intersectObject(mesh, false);
    if (hits.length > 0) {
      const faceIndex = hits[0].faceIndex;
      if (faceIndex != null && faceIndex >= 0 && faceIndex < PAGES.length) {
        if (focusIndex === faceIndex) {
          window.location.href = PAGES[faceIndex].slug;
        } else {
          openInfo(faceIndex);
        }
        return;
      }
    }

    if (focusIndex !== null) {
      closeInfo();
    }
  }

  // ================== ANIMATION LOOP ==================

  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const now = performance.now();

    if (focusIndex !== null && now - lastInteractionTime > IDLE_RETURN_MS) {
      closeInfo();
    }

    if (focusIndex === null && !isDraggingCanvas && !activeTween) {
      mesh.rotation.y += 0.12 * dt;
      mesh.rotation.x = Math.sin(clock.elapsedTime * 0.12) * 0.05;
      edges.rotation.copy(mesh.rotation);
    }

    updateWave(dt);

    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  }
  animate();

  // ================== RESIZE ==================

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    updateSlotSpacers();
    requestAnimationFrame(updateSlotAppearance);
  });

  // 初期選択
  selectIndex(0, { fromScroll: false });
</script>





</body>
</html>


